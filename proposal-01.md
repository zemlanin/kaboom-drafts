Функции в data-kaboom (k-функции) не требуют произвольного количества аргументов и могут работать с двумя и тремя аргументами:

* (node, cb) - функции, либо не имеющие, либо игнорирующие результаты предыдущих функций в цепочке. Результат своей работы, они передают в cb()

* (node, ev, cb) - функции в середине и в конце цепочки

* (!) Можно придумать полезное применение для обычного return из k-функций

Трёх аргументов достаточно для описания состояния целевой ноды (через node), состояния цепочки (ev) и результата операции. Таким образом, цепочка в data-kaboom может содержать имена k-функций (с именами их namespace), опциональные айдишники целевых нод и разделители:

    data-kaboom="DOM/visible?#other : C/not : DOM/visible!"

    #other - id целевой ноды
    DOM, C - модули для работы с DOM и базовыми функциями (**C**ore)
    visible?, visible! - возвращающая состояние и изменяющая состояние функции. Символы в конце (глифы) могут быть общим соглашением

Как видно из примера, в этом языке нет литералов (кроме, в какой-то мере, id других нод), которые могут пригодиться для функций вроде DOM/addClass. Их роль могут играть функции, достающие данные из data-атрибутов (data-bazooka специально пропущено):

    <span data-x1="tick,tock" data-kaboom="
        DOM/click : X/1 : Toggler/innerText
    ">tick</span>

Использовать для этих целей основные k-функции может быть недостаточно, т.к. они могут:

* Вызываться несколько раз из разных нод — проблема с выборов ноды-источника данных
* Вызываться несколько раз из одной ноды — проблема с тем, что на разные вызовы нужны разные литералы

Сам Kaboom выполняет цепочки с конца, заворачивая каждую k-функцию в обёртку замыкания, которое будет передано как последний аргумент предыдущей в цепочке функции
